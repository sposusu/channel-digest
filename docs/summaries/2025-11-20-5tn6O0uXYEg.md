# Build a Research Agent with Deep Agents

**Channel:** LangChain
**Published:** 2025-11-20
**Video:** [Watch on YouTube](https://youtube.com/watch?v=5tn6O0uXYEg)

---

# Langchain Deep Agents 快速入門導覽

## 重點摘要
Deep Agents 是一個開源的 Agent 工具框架，它內建了規劃、電腦存取和子代理人委派等強大功能。這讓開發者能專注於透過自訂工具和精細的提示詞來打造能夠處理複雜任務的 Agent，影片以一個研究任務為例，完整展示了如何設定、執行與部署。

## 故事大綱
- **開場**：Langchain 的 Lance 介紹了 Deep Agents，一個模仿 Devin 和 Cloud Code 等先進 Agent 的開源框架。他首先展示了一個執行研究任務的 UI 範例，呈現了最終的報告成果與過程中的工具呼叫軌跡。
- **中段**：影片深入探討其運作原理。首先解釋了框架內建的原子工具（如待辦事項、檔案系統、Shell 指令、任務委派），接著說明如何透過三項客製化來擴充：1) **任務專用工具**（如搜尋、強迫反思的「思考」工具）；2) **任務專用指令**（提示詞是關鍵，包含提供經驗法則、設定預算以防止「空轉」）；3) **任務專用子代理人**（用於隔離上下文，處理高權杖消耗的子任務）。他還解釋了 LangGraph 的「中介軟體」(middleware) 如何提供這些工具並管理 Agent 生命週期。
- **結尾**：Lance 演示了兩種執行方式：在 Jupyter Notebook 中進行互動式檢查，以及透過 `langgraph dev` 部署為可連接前端 UI 的應用程式。他總結 Deep Agents 是一個通用的基礎框架，開發者的重點應放在提示詞工程和工具定義上，並鼓勵社群貢獻。

## 關鍵見解
1.  **內建強大基礎**：Deep Agents 提供一個可重用的框架，內建了規劃、檔案系統、子代理人等基本工具，省去開發者為每個 Agent 重複造輪子的麻煩。
2.  **客製化三要素**：成功的 Agent 開發依賴三大客製化：任務專用的工具、詳細的指令（提示詞），以及特化的子代理人。
3.  **提示詞工程至關重要**：提供經驗法則、設定預算（如最大工具呼叫次數）和定義清晰的委派策略，可以有效防止 Agent 陷入「空轉」（無意義地重複搜尋）等常見的失敗模式。
4.  **子代理人實現上下文隔離**：子代理人是處理複雜任務的強大模式，讓高權杖消耗的子任務能被獨立處理，其結果再回傳給主代理人，避免污染主代理人的上下文視窗。
5.  **以「背誦」技巧確保任務完成**：影片展示了一種稱為「背誦」(recitation) 的技巧，即先將原始請求寫入檔案，在執行一系列任務後，再讀取該檔案以驗證最終產出是否符合初衷，確保 Agent 不偏離軌道。

## 精彩時刻
- 「提示詞還沒死。它在 Agent 領域中依然非常活躍且重要。」
- 「空轉 (spin out)」：一個用來描述 Agent 在已收集足夠資訊後，仍無止盡地繼續搜尋的行為的術語。
- 「思考 (think)」工具：一個本身不做任何事，卻能強制 Agent 暫停並產生反思的巧妙技巧，有助於審核其思考過程並提升表現。
- 預設的檔案操作是在記憶體內的 `state` 物件中進行，而非直接寫入本機檔案系統，但可以輕易配置不同的後端（如沙盒或本機檔案系統）。

---

# A Tour of Langchain's Deep Agents Quick Start

## TL;DR
Deep Agents is an open-source agent harness that bakes in powerful tools for planning, computer access, and sub-agent delegation. This allows developers to focus on building complex, task-oriented agents by providing custom tools and sophisticated prompts, as demonstrated with a complete walkthrough of a research agent example.

## Story Flow
- **Beginning**: Lance from Langchain introduces Deep Agents, an open-source framework inspired by advanced agents like Devin and Cloud Code. He starts by showing a UI running a research task, presenting the final report and the trajectory of tool calls made along the way.
- **Middle**: The video dives into what's under the hood. It first explains the built-in atomic tools (e.g., to-dos, file system, shell commands, task delegation). It then details how to extend it via three key customizations: 1) **Task-specific tools** (like a search tool and a "think" tool to enforce reflection), 2) **Task-specific instructions** (prompting is key, including heuristics and budgets to prevent "spin out"), and 3) **Task-specific sub-agents** (used for context isolation in token-heavy tasks). He also clarifies how LangGraph's "middleware" provides these tools and manages the agent lifecycle.
- **End**: Lance demonstrates two ways to run the agent: interactively in a Jupyter Notebook for inspection, and as a deployable application via `langgraph dev` that can connect to a front-end UI. He concludes that Deep Agents is a general-purpose harness, and the developer's focus should be on prompt engineering and tool definition, inviting community contributions.

## Key Insights
1.  **Powerful Foundation Included**: Deep Agents provides a reusable harness with fundamental tools for planning, file system access, and sub-agents, saving developers from reinventing the wheel for each new agent.
2.  **The Trifecta of Customization**: Effective agent development relies on three key customizations: task-specific tools, detailed instructions (prompts), and specialized sub-agents.
3.  **Prompt Engineering is Critical**: Providing heuristics, setting budgets (e.g., max tool calls), and defining a clear delegation strategy can effectively prevent common failure modes like "spin out" (endless, unproductive searching).
4.  **Sub-Agents for Context Isolation**: Sub-agents are a powerful pattern for complex tasks. They handle token-heavy sub-tasks in isolation and return only the final result to the parent agent, keeping its context window clean.
5.  **Ensuring Task Completion with "Recitation"**: The video highlights a technique called "recitation," where the agent first writes the original request to a file. After performing its tasks, it reads that file back to verify that the final output addresses the initial goal, keeping the agent on track.

## Notable Moments
- "Prompting is not dead. It's still very much alive and very important with agents."
- "Spin out": A term used to describe an agent's behavior of continuing to search for information long after it has collected enough to answer the question.
- The "think" tool: A clever trick that does nothing but forces the agent to pause and produce a reflection, which is useful for auditing its thought process and improving performance.
- By default, file operations occur in an in-memory `state` object, not the local file system, but it can be easily configured to use different backends (like a sandbox or the local file system).
