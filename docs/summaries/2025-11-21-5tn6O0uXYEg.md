# Build a Research Agent with Deep Agents

**Channel:** LangChain
**Published:** 2025-11-21
**Video:** [Watch on YouTube](https://youtube.com/watch?v=5tn6O0uXYEg)

---

# LangChain 深度代理 (Deep Agents) 快速入門：打造強大 AI 代理的開源工具

## 重點摘要
LangChain 推出的 Deep Agents 是一個開源的代理框架，它將強大代理所需的關鍵功能——規劃、電腦存取和子代理委派——內建為標準工具。開發者可以透過提供自訂工具、提示詞和子代理，輕鬆地將其應用於特定場景，如此影片中的研究任務所示。

## 故事大綱
- **開場**：LangChain 的 Lance 介紹 Deep Agents，這是一個開源框架，旨在簡化複雜 AI 代理的開發。它整合了如 Devin 和 Cloud Code 等知名代理所使用的核心概念，並透過一個快速入門專案來展示其功能，首先聚焦於最受歡迎的研究應用場景。
- **中段**：Lance 實際操作了一個為 Deep Agents 打造的本地 UI，展示了研究代理如何接收請求、執行一系列工具調用（如搜尋、寫入檔案、思考），並最終生成一份帶有引用來源的完整報告。他接著深入解析其運作原理：Deep Agents 內建了一套原子工具（如檔案系統操作、待辦事項清單、任務委派工具），開發者則需提供三樣東西：1) 特定任務的工具（如搜尋、用於強制反思的`think`工具）；2) 特定任務的指令（即提示詞，包含研究策略、防止「空轉」的預算限制）；3) 用於「上下文隔離」的子代理。他還解釋了 LangGraph 的「中介軟體 (middleware)」概念，它不僅提供工具集，還能像鉤子一樣在代理執行循環中插入摘要、快取等功能。
- **結尾**：Lance 展示了代理的完整執行流程：將使用者請求寫入記憶體、建立待辦事項、委派給子代理進行深度研究、撰寫最終報告，並讀取最初的請求以驗證報告是否切題。他強調這一切都可以在 LangSmith 中追蹤，並可透過 `langgraph dev` 指令部署為服務。最後，他總結 Deep Agents 是一個通用且易於改編的強大框架，並鼓勵社群參與貢獻。

## 關鍵見解
1.  **強大代理的核心三要素**：成功的代理建立在幾個基本能力之上：規劃（待辦事項）、電腦存取（檔案系統、Shell）和子代理委派。Deep Agents 將這些功能標準化，讓開發者不必重複造輪子。
2.  **客製化是釋放潛能的關鍵**：框架本身只是基礎。真正的威力來自於針對特定任務提供精準的工具（如網路搜尋）、詳細的指令（提示詞），以及專門化的子代理。
3.  **用子代理進行「上下文隔離」**：將耗費大量 token 的任務（如研究）委派給子代理，主代理只接收最終結果。這是一種極為有效的模式，可以防止主代理的上下文視窗被污染或溢出。
4.  **結構化提示詞的重要性**：有效的提示詞對於引導代理至關重要。這包括給予它經驗法則（如「像研究員一樣思考」）、設定限制（如工具調用次數上限以防止「空轉」），以及明確的委派策略。
5.  **記憶體即是草稿紙**：代理預設使用 LangGraph 的記憶體狀態來進行檔案操作，這就像一個高效的草稿紙。它實現了「複誦 (recitation)」技巧——先把目標寫下，完成工作後再回頭讀取目標，以確保任務被正確完成。

## 精彩時刻
- **「提示詞還沒死」**：「Prompting is not dead. It's still very much alive and very important with agents.」這句話強調了在代理開發中，提示詞工程依然扮演著至關重要的角色。
- **「思考工具 (think tool)」**：一個本身不做任何事、僅僅是為了強迫代理停下來產生一段反思的工具。這個簡單的設計讓代理的思考過程變得透明且易於審核。
- **「空轉 (spin-out)」問題**：指代理陷入無休止的搜尋循環而無法取得進展。影片提出了在提示詞中設定預算和啟發式規則來預防此問題。
- **中介軟體即「鉤子 (hooks)」**：將 LangGraph 的中介軟體解釋為不僅是工具提供者，更是在代理生命週期中注入摘要、人類審核等邏輯的「鉤子」，這個比喻非常清晰。

---

# LangChain Deep Agents Quick Start: An Open-Source Harness for Building Powerful AI Agents

## TL;DR
Deep Agents is an open-source harness from LangChain that simplifies building complex agents by providing built-in tools for planning, computer access, and sub-agent delegation. Developers can easily adapt it for specific use cases, like the research task shown in the video, by supplying custom tools, prompts, and sub-agents.

## Story Flow
- **Beginning**: Lance from LangChain introduces Deep Agents, an open-source harness designed to simplify the creation of complex AI agents. It implements key concepts from popular agents like Devin and Cloud Code and showcases its capabilities through a quick-start repo, beginning with a popular research use case.
- **Middle**: Lance runs a live demo using a local UI built for Deep Agents, showing how a research agent takes a request, executes a series of tool calls (search, write file, think), and produces a fully cited report. He then breaks down how it works: Deep Agents comes with a set of atomic, built-in tools (for file system operations, to-do lists, task delegation). The developer provides three key things: 1) task-specific tools (like a search tool and a `think` tool to enforce reflection), 2) task-specific instructions (prompts containing research strategies and budgets to prevent "spin-out"), and 3) sub-agents for "context isolation." He also explains LangGraph's "middleware" concept, which not only provides toolsets but also acts as hooks for summarization, caching, and other functions in the agent loop.
- **End**: Lance demonstrates the agent's full execution flow: writing the user request to memory, creating to-dos, delegating the core research to a sub-agent, writing the final report, and reading the original request to verify completion. He notes this is all traceable in LangSmith and can be deployed as a server with `langgraph dev`. He concludes that Deep Agents is a general, adaptable harness for building powerful agents and encourages community contributions.

## Key Insights
1.  **The Core Primitives of Powerful Agents**: Successful agents are built on a few fundamental capabilities: planning (to-do lists), computer access (file system, shell), and sub-agent delegation. Deep Agents standardizes these so developers don't have to reinvent them.
2.  **Customization is Key to Unlock Potential**: The harness is a foundation. Its true power is unlocked by providing task-specific tools (e.g., web search), detailed instructions (prompts), and specialized sub-agents.
3.  **Context Isolation with Sub-Agents**: Delegating token-heavy tasks (like research) to a sub-agent, with the main agent only receiving the final result, is a powerful pattern to prevent the main agent's context window from overflowing.
4.  **The Importance of Structured Prompting**: Effective prompting is crucial for guiding agents. This includes giving them heuristics ("think like a researcher"), constraints (budgets on tool calls to prevent "spin-out"), and a clear delegation strategy.
5.  **In-Memory State as a Scratchpad**: The agent uses LangGraph's in-memory state for file operations by default, acting as an efficient scratchpad. This enables the "recitation" technique: writing the goal down, doing work, then reading the goal back to verify the task was completed correctly.

## Notable Moments
- **"Prompting is not dead"**: "Prompting is not dead. It's still very much alive and very important with agents." This quote emphasizes the critical and ongoing role of prompt engineering in agent development.
- **The "think tool"**: A clever tool that does nothing but forces the agent to pause and produce a reflection. This simple design makes the agent's reasoning process transparent and auditable.
- **The "spin-out" problem**: A term for when an agent gets stuck in a repetitive loop of searching without making progress. The video suggests using budgets and heuristics in prompts to prevent this.
- **Middleware as "hooks"**: The clear explanation of LangGraph middleware as not just tool providers, but as "hooks" that can inject logic like summarization or human approval at different points in the agent's lifecycle.
