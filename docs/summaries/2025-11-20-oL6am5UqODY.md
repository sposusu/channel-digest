# Agents Gone Wild? Use Tool Call Limits in LangChainJS to Keep Them in Check!

**Channel:** LangChain
**Published:** 2025-11-20
**Video:** [Watch on YouTube](https://youtube.com/watch?v=oL6am5UqODY)

---

# 使用 LangChain 工具中間件控制您的 AI 代理成本

## 重點摘要
本影片介紹 LangChain 中的「工具呼叫中間件 (Tool Call Middleware)」，這是一個無需在程式中寫死規則，就能為 AI 代理 (Agent) 的工具設置使用次數、費率或額度上限的宣告式方法，有效控制 API 成本並防止濫用。

## 故事大綱
- **開場**：影片開頭點出一個常見問題：AI 代理可能會無節制地呼叫付費 API（如簡訊服務），導致開發者成本失控。講者 Christian 提出 LangChain 的「工具呼叫中間件」作為解決方案。
- **中段**：他解釋了此中間件如何在模型決定呼叫工具後進行攔截、計數並執行限制。接著透過程式碼示範，建立一個能發送簡訊的代理，並對其設定兩種限制：
    1.  **對話限制 (Thread Limit)**：設定整場對話只能發送 3 則簡訊，當嘗試發送第 4 則時，系統就會報錯中止。
    2.  **單次執行限制 (Run Limit)**：設定單次指令只能並行發送 2 則簡訊。當嘗試一次發送 4 則時，若中止行為設為 `error`，則所有簡訊都會失敗；若設為 `continue`，則只有前 2 則會成功發送，其餘的會被優雅地拒絕。
- **結尾**：結論是，任何與付費或有速率限制的 API 互動的代理，都應該從第一天起就加入這個中間件作為保護機制。講者也提供了範例程式碼的連結供觀眾參考。

## 關鍵見解
- **成本風險**：不受控制的 AI 代理會因過度使用 API 而產生高昂費用。
- **宣告式防護**：工具呼叫中間件提供了一種乾淨、宣告式的方法來設定使用上限，而非在程式邏輯中寫死一堆判斷式。
- **靈活的限制範圍**：可以針對單一工具設定限制，範圍可涵蓋單次執行 (`run_limit`) 或整個對話 (`thread_limit`)。
- **可控的中止行為**：當達到上限時，可以決定代理的行為：是直接報錯 (`error`)，還是繼續執行但回報部分失敗 (`continue`)。
- **生產級應用的基石**：對於要產品化的代理來說，這是一個確保系統穩定且符合成本效益的關鍵模式。

## 精彩時刻
- **經典比喻**：「如果你的代理在用戶只有兩則簡訊額度時發了五則，猜猜誰來買單？」
- **清楚的示範**：透過「一次傳給全家」的指令，清楚展示了 `run_limit`（單次執行限制）與 `thread_limit`（對話總量限制）的區別。
- **行為差異**：`exit: 'continue'` 的設定讓代理能夠優雅地處理超額請求，它會回報「我成功發送了兩則簡訊，但其餘的因額度限制被拒絕了」，而不是讓整個任務完全失敗。

---

# Control Your Agent's API Costs with LangChain's Tool Call Middleware

## TL;DR
This video introduces LangChain's "Tool Call Middleware," a declarative way to set usage caps, rate limits, or credit limits on an agent's tools. It effectively prevents excessive API calls and controls costs without needing hard-coded guardrails in your system prompt.

## Story Flow
- **Beginning**: The video starts by addressing a common problem: an AI agent going "nuts" with paid API calls (like an SMS service), leading to uncontrolled costs for the developer. The speaker, Christian, presents the Tool Call Middleware as the solution.
- **Middle**: He explains that this middleware hooks into the agent loop, intercepting tool calls to count them and enforce limits. This is followed by a code demo featuring an agent that sends SMS messages. He demonstrates two types of limits:
    1.  **Thread Limit**: He sets a limit of 3 messages for the entire conversation. When he tries to send a fourth, the system errors out as expected.
    2.  **Run Limit**: He sets a limit of 2 messages per single invocation. When he asks the agent to text his whole family (4 people) at once, the behavior depends on the `exit` configuration. With `exit: 'error'`, all four calls fail. With `exit: 'continue'`, the first two messages are sent successfully while the other two fail gracefully.
- **End**: The video concludes that this middleware is a crucial guardrail that should be added on day one for any agent that interacts with paid or rate-limited APIs. The speaker provides a link to the exact example code in the LangChain repository.

## Key Insights
- **Cost Risk**: Uncontrolled agents can lead to unexpectedly high costs due to their ability to overuse APIs.
- **Declarative Guardrails**: The Tool Call Middleware offers a clean, declarative way to set usage limits, rather than embedding complex conditional logic directly in the code.
- **Flexible Scoping**: Limits can be applied granularly per tool and can be scoped to a single invocation (`run_limit`) or an entire conversation thread (`thread_limit`).
- **Controllable Exit Behavior**: You can define how the agent should react when a limit is reached, whether it's by throwing an error (`error`) or by allowing partial success and reporting the failures (`continue`).
- **A Pattern for Production**: This is an essential pattern for building production-ready agents that are both robust and financially safe.

## Notable Moments
- **The Core Analogy**: "If your agent sends five messages when your user actually has just credit for two, guess who pays the bill?"
- **Clear Demonstration**: The difference between `run_limit` and `thread_limit` is made very clear with the "text my whole family" example.
- **Behavioral Difference**: The demo of `exit: 'continue'` powerfully shows how the agent can gracefully handle limits, reporting back, "I was successfully able to send two messages, but the others were restricted due to credit limits," instead of failing the entire task.
